/**
 * Each offer represents flights you can buy from an airline at a particular price that meet your search criteria.
 * @link https://duffel.com/docs/api/offers/schema
 */
interface Offer {
    /**
     * The types of identity documents that may be provided for the passengers when creating an order based on this offer.
     * Currently, the only supported type is `passport`. If this is `[]`, then you must not provide identity documents.
     */
    allowed_passenger_identity_document_types: PassengerIdentityDocumentType[];
    /**
     * The services that can be booked along with the offer but are not included by default, for example an additional checked bag.
     * This field is only returned in the Get single offer endpoint.
     * When there are no services available, or we don't support services for the airline, this list will be empty.
     */
    available_services: OfferAvailableService[];
    /**
     * The base price of the offer for all passengers, excluding taxes.
     * It does not include the base amount of any service(s) that might be booked with the offer.
     */
    base_amount: string;
    /**
     * The currency of the `base_amount`, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code
     */
    base_currency: string;
    /**
     * The conditions associated with this offer, describing the kinds of modifications you can make post-booking and any penalties that will apply to those modifications.
     * This information assumes the condition is applied to all of the slices and passengers associated with this offer - for information at the slice level (e.g. "what happens if I just want to change the first slice?") refer to the `slices`.
     * If a particular kind of modification is allowed, you may not always be able to take action through the Duffel API.
     * In some cases, you may need to contact the Duffel support team or the airline directly.
     */
    conditions: FlightsConditions;
    /**
     * The ISO 8601 datetime at which the offer was created
     */
    created_at: string;
    /**
     * The ISO 8601 datetime at which the offer will expire and no longer be usable to create an order
     */
    expires_at: string;
    /**
     * Duffel's unique identifier for the offer
     */
    id: string;
    /**
     * Whether the offer request was created in live mode.
     * This field will be set to `true` if the offer request was created in live mode, or `false` if it was created in test mode.
     */
    live_mode: boolean;
    /**
     * The airline which provided the offer
     */
    owner: Airline;
    /**
     * Whether identity documents must be provided for each of the passengers when creating an order based on this offer.
     * If this is `true`, you must provide an identity document for every passenger.
     */
    passenger_identity_documents_required: boolean;
    /**
     * The passengers included in the offer
     */
    passengers: OfferPassenger[];
    /**
     * The payment requirements for this offer
     */
    payment_requirements: PaymentRequirements;
    /**
     * The slices that make up this offer. Each slice will include one or more segments,
     * the specific flights that the airline is offering to take the passengers from the slice's `origin` to its `destination`.
     */
    slices: OfferSlice[];
    /**
     * The amount of tax payable on the offer for all passengers
     */
    tax_amount: string | null;
    /**
     * The currency of the `tax_amount`, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code
     */
    tax_currency: string | null;
    /**
     * The total price of the offer for all passengers, including taxes.
     * It does not include the total price of any service(s) that might be booked with the offer.
     */
    total_amount: string;
    /**
     * An estimate of the total carbon dioxide (CO₂) emissions when
     * all of the passengers fly this offer's itinerary, measured in kilograms
     */
    total_emissions_kg: string;
    /**
     * The currency of the `total_amount`, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code
     */
    total_currency: string;
    /**
     * The ISO 8601 datetime at which the offer was last updated
     */
    updated_at: string;
}
interface OfferAvailableServiceBaggageMetadata {
    /**
     * The maximum weight that the baggage can have in kilograms
     */
    maximum_weight_kg: number | null;
    /**
     * The maximum height that the baggage can have in centimetres
     */
    maximum_height_cm: number | null;
    /**
     * The maximum length that the baggage can have in centimetres
     */
    maximum_length_cm: number | null;
    /**
     * The maximum depth that the baggage can have in centimetres
     */
    maximum_depth_cm: number | null;
    /**
     * The type of the baggage
     */
    type: BaggageType;
}
interface PaymentRequirements {
    /**
     *  The ISO 8601 datetime by which you must pay for this order.
     * At this time, if still unpaid, the reserved space on the flight(s)
     * will be released and you will have to create a new order.
     * This will be null only for orders where `awaiting_payment` is `false`.
     */
    payment_required_by?: string | null;
    /**
     *  The ISO 8601 datetime at which the price associated
     * with the order will no longer be guaranteed by the airline
     * and the order will need to be repriced before payment.
     * This can be null when there is no price guarantee.
     */
    price_guarantee_expires_at?: string | null;
    /**
     * Whether immediate payment is required or not
     */
    requires_instant_payment: boolean;
}
interface OfferAvailableServiceMetadataMap {
    baggage: OfferAvailableServiceBaggageMetadata;
}
declare type OfferAvailableServiceType = keyof OfferAvailableServiceMetadataMap;
interface OfferAvailableService<T_ServiceType extends OfferAvailableServiceType = 'baggage'> {
    /**
     * Duffel's unique identifier for the service
     */
    id: string;
    /**
     * The maximum quantity of this service that can be booked with an order
     */
    maximum_quantity: number;
    /**
     * An object containing metadata about the service, like the maximum weight and dimensions of the baggage.
     */
    metadata?: OfferAvailableServiceMetadataMap[T_ServiceType];
    /**
     * The list of passenger `id`s the service applies to.
     * If you add this service to an order it will apply to all the passengers in this list.
     * For services where the type is `baggage`, this list will include only a single passenger.
     */
    passenger_ids: string[];
    /**
     * The list of segment ids the service applies to.
     * If you add this service to an order it will apply to all the segments in this list.
     * For services where the type is baggage, depending on the airline,
     * this list includes all the segments of all slices or all the segments of a single slice.
     */
    segment_ids: string[];
    /**
     * The total price of the service for all passengers and segments it applies to, including taxes
     */
    total_amount: string;
    /**
     * The currency of the `total_amount`, as an ISO 4217 currency code
     */
    total_currency: string;
    /**
     * The type of the service.
     * For now we only return services of type baggage but we will return other types in the future.
     * We won't consider adding new service types a break change.
     */
    type: T_ServiceType;
}
interface OfferPassenger {
    /**
     * The age of the passenger on the departure_date of the final slice.
     */
    age?: number;
    /**
     * The type of the passenger.
     */
    type?: 'adult';
    /**
     * The passenger's family name. Only `space`, `-`, `'`, and letters from the `ASCII`, `Latin-1 Supplement` and `Latin
     * Extended-A` (with the exceptions of `Æ`, `æ`, `Ĳ`, `ĳ`, `Œ`, `œ`, `Þ`, , and `ð`) Unicode charts are accepted. All
     * other characters will result in a validation error. The minimum length is 1 character, and the maximum is 20
     * characters.
     *
     * This is only required if you're also including **Loyalty Programme Accounts**.
     */
    family_name?: string;
    /**
     * The passenger's given name. Only `space`, `-`, `'`, and letters from the `ASCII`, `Latin-1 Supplement` and `Latin
     * Extended-A` (with the exceptions of `Æ`, `æ`, `Ĳ`, `ĳ`, `Œ`, `œ`, `Þ`, , and `ð`) Unicode charts are accepted. All
     * other characters will result in a validation error. The minimum length is 1 character, and the maximum is 20
     * characters.
     *
     * This is only required if you're also including **Loyalty Programme Accounts**.
     */
    given_name?: string;
    /**
     * The **Loyalty Programme Accounts** for this passenger.
     */
    loyalty_programme_accounts?: LoyaltyProgrammeAccount[];
    /**
     * The identifier for the passenger, unique within this Offer Request and across all Offer Requests.
     * This ID will be generated by Duffel unless you had optionally provided one.
     * Optionally providing one has been deprecated.
     */
    id: string;
}
interface OfferSlice {
    /**
     * The type of the destination
     */
    destination_type: PlaceType;
    /**
     * The city or airport where this slice ends
     */
    destination: Place;
    /**
     * The type of the origin
     */
    origin_type: PlaceType;
    /**
     * The city or airport where this slice begins
     */
    origin: Place;
    /**
     * The duration of the slice, represented as a ISO 8601 duration
     */
    duration: string | null;
    /**
     * The name of the fare brand associated with this slice.
     * A fare brand specifies the travel conditions you get on your slice made available
     * by the airline. e.g. a British Airways Economy Basic fare will only include a hand baggage allowance.
     * It is worth noting that the fare brand names are defined by the airlines themselves and therefore they
     * are subject to change without any prior notice. We're in the process of adding support for fare_brand_name across
     * all our airlines, so for now, this field may be null in some offers.
     * This will become a non-nullable attribute in the near future.
     */
    fare_brand_name: string | null;
    /**
     * Duffel's unique identifier for the slice. It identifies the slice of an offer (i.e. the same slice across offers will have different `id`s
     */
    id: string;
    /**
     * The segments - that is, specific flights - that the airline is offering to get the passengers from the `origin` to the `destination`
     */
    segments: OfferSliceSegment[];
    /**
     * The conditions associated with this slice, describing the kinds of modifications you can make post-booking and any penalties that will apply to those modifications.
     * This condition is applied only to this slice and to all the passengers associated with this offer - for information at the offer level (e.g. "what happens if I want to change all the slices?") refer to the conditions at the top level.
     * If a particular kind of modification is allowed, you may not always be able to take action through the Duffel API.
     * In some cases, you may need to contact the Duffel support team or the airline directly.
     */
    conditions: FlightsConditions;
}
interface OfferSliceSegment {
    /**
     * The aircraft that the operating carrier will use to operate this segment
     */
    aircraft: Aircraft$1;
    /**
     * The ISO 8601 datetime at which the segment is scheduled to arrive
     */
    arriving_at: string;
    /**
     * The terminal at the destination airport where the segment is scheduled to arrive
     */
    destination_terminal: string | null;
    /**
     * The ISO 8601 datetime at which the segment is scheduled to depart
     */
    departing_at: string;
    /**
     * The terminal at the origin airport from which the segment is scheduled to depart
     */
    origin_terminal: string | null;
    /**
     * The airport at which the segment is scheduled to arrive
     */
    destination: Airport;
    /**
     * The distance of the segment in kilometres
     */
    distance: string | null;
    /**
     * The duration of the segment, represented as a ISO 8601 duration
     */
    duration: string | null;
    /**
     * Duffel's unique identifier for the segment. It identifies the segment of an offer (i.e. the same segment across offers will have different `id`s
     */
    id: string;
    /**
     * The airline selling the tickets for this segment.
     * This may differ from the `operating_carrier` in the case of a "codeshare", where one airline sells flights operated by another airline.
     */
    marketing_carrier: Airline;
    /**
     * The flight number assigned by the marketing carrier
     */
    marketing_carrier_flight_number: string;
    /**
     * The airport from which the flight is scheduled to depart
     */
    origin: Airport;
    /**
     * The airline actually operating this segment.
     * This may differ from the marketing_carrier in the case of a "codeshare", where one airline sells flights operated by another airline.
     */
    operating_carrier: Airline;
    /**
     * The flight number assigned by the operating carrier
     */
    operating_carrier_flight_number: string;
    /**
     * Additional segment-specific information about the passengers included in the offer (e.g. their baggage allowance and the cabin class they will be travelling in)
     */
    passengers: OfferSliceSegmentPassenger[];
}
interface OfferSliceSegmentPassenger {
    /**
     * The baggage allowances for the passenger on this segment included in the offer.
     * Some airlines may allow additional baggage to be booked as a service - see the offer's available_services.
     */
    baggages: OfferSliceSegmentPassengerBaggage[];
    /**
     * The cabin class that the passenger will travel in on this segment
     */
    cabin_class: CabinClass;
    /**
     * The name that the marketing carrier uses to market this cabin class
     */
    cabin_class_marketing_name: string;
    /**
     * The identifier for the passenger.
     * You may have specified this ID yourself when creating the offer request, or otherwise, Duffel will have generated its own random ID.
     */
    passenger_id: string;
    /**
     * The airline's alphanumeric code for the fare that the passenger is using to travel. Where this is `null`, it means that either the
     * fare basis code is not available or the airline does not use fare basis codes.
     */
    fare_basis_code: string;
}
declare type BaggageType = 'carry_on' | 'checked';
interface OfferSliceSegmentPassengerBaggage {
    /**
     * The type of the baggage allowance
     */
    type: BaggageType;
    /**
     * The number of this type of bag allowed on the segment. Note that this can currently be 0 in some cases.
     */
    quantity: number;
}
interface ListOffersParams extends PaginationMeta {
    /**
     * Duffel's unique identifier for the offer request, returned when it was created
     */
    offer_request_id: string;
    /**
     * Allows to filter the offers list by the maximum number of connections in a given offer. e.g. a return flight with three flights outbound and a direct inbound flight would be filtered out if `max_connections=1` was passed.
     */
    max_connections?: number;
    /**
     * By default, the offers will be returned sorted by ID in ascending order.
     * This parameter allows you to sort the list of offers by `total_amount` or `total_duration`.
     * By default the sorting order will be ascending, if you wish to sort in descending order a - will need to be prepended to the sorting attribute (i.e: `-total_amount`).
     */
    sort?: 'total_amount' | 'total_duration';
}
interface LoyaltyProgrammeAccounts {
    /**
     * The passenger's account number for this Loyalty Programme Account
     */
    account_number: string;
    /**
     * The IATA code for the airline that this Loyalty Programme Account belongs to
     */
    airline_iata_code: string;
}
interface UpdateOffer {
    type: string;
    loyalty_programme_accounts: LoyaltyProgrammeAccounts;
    id: string;
    given_name: string;
    family_name: string;
    age: number;
}

interface OfferRequestSlice {
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date on which the passengers want to depart
     */
    departure_date: string;
    /**
     * The city or airport the passengers want to travel to
     */
    destination: Place | string;
    /**
     * The city or airport the passengers want to depart from
     */
    origin: Place | string;
    /**
     * The type of the origin
     */
    origin_type: PlaceType;
    /**
     * The type of the destination
     */
    destination_type: PlaceType;
}
/**
 * The passengers who want to travel. A passenger will have only a type or an age.
 */
interface OfferRequestPassenger {
    /**
     * The age of the passenger on the `departure_date` of the final slice.
     */
    age?: number;
    /**
     * The type of the passenger.
     */
    type?: 'adult';
    /**
     * The passenger's family name. Only `space`, `-`, `'`, and letters from the `ASCII`, `Latin-1 Supplement` and `Latin
     * Extended-A` (with the exceptions of `Æ`, `æ`, `Ĳ`, `ĳ`, `Œ`, `œ`, `Þ`, , and `ð`) Unicode charts are accepted. All
     * other characters will result in a validation error. The minimum length is 1 character, and the maximum is 20
     * characters.
     *
     * This is only required if you're also including **Loyalty Programme Accounts**.
     */
    family_name?: string;
    /**
     * The passenger's given name. Only `space`, `-`, `'`, and letters from the `ASCII`, `Latin-1 Supplement` and `Latin
     * Extended-A` (with the exceptions of `Æ`, `æ`, `Ĳ`, `ĳ`, `Œ`, `œ`, `Þ`, , and `ð`) Unicode charts are accepted. All
     * other characters will result in a validation error. The minimum length is 1 character, and the maximum is 20
     * characters.
     *
     * This is only required if you're also including **Loyalty Programme Accounts**.
     */
    given_name?: string;
    /**
     * The **Loyalty Programme Accounts** for this passenger.
     */
    loyalty_programme_accounts?: LoyaltyProgrammeAccount[];
    /**
     * The identifier for the passenger, unique within this Offer Request and across all Offer Requests.
     * This ID will be generated by Duffel unless you had optionally provided one.
     * Optionally providing one has been deprecated.
     */
    id: string;
}
/**
 * The **Loyalty Programme Account** details.
 */
interface LoyaltyProgrammeAccount {
    /**
     * The passenger's account number for this **Loyalty Programme Account**.
     */
    account_number: string;
    /**
     * The IATA code for the airline that this **Loyalty Programme Account** belongs to.
     */
    airline_iata_code: Airline['iata_code'];
}
/**
 * To search for flights, you'll need to create an offer request.
 * An offer request describes the passengers and where and when they want to travel (in the form of a list of slices).
 * It may also include additional filters (e.g. a particular cabin to travel in).
 * @link https://duffel.com/docs/api/offer-requests/schema
 */
interface OfferRequest {
    /**
     * The slices that make up this offer request.
     * One-way journeys can be expressed using one slice, whereas return trips will need two.
     * @link https://duffel.com/docs/api/overview/key-principles
     */
    slices: OfferRequestSlice[];
    /**
     * The cabin that the passengers want to travel in
     */
    cabin_class?: CabinClass;
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime at which the offer request was created
     */
    created_at: string;
    /**
     * Duffel's unique identifier for the offer request
     */
    id: string;
    /**
     * Whether the offer request was created in live mode. This field will be set to true if the offer request was created in live mode, or false if it was created in test mode.
     */
    live_mode: boolean;
    /**
     * The offers returned by the airlines
     */
    offers: Omit<Offer, 'available_services'>[];
    /**
     * The passengers who want to travel. A passenger will have only a type or an age.
     */
    passengers: OfferRequestPassenger[];
}
interface CreateOfferRequest {
    /**
     * The cabin that the passengers want to travel in
     */
    cabin_class?: CabinClass;
    /**
     * The passengers who want to travel.
     * If you specify an age for a passenger, the type may differ for the same passenger in different offers due to airline's different rules. e.g. one airline may treat a 14 year old as an adult, and another as a young adult.
     */
    passengers: Omit<OfferRequestPassenger, 'id'>[];
    /**
     * The [slices](https://duffel.com/docs/api/overview/key-principles) that make up this offer request.
     * One-way journeys can be expressed using one slice, whereas return trips will need two.
     */
    slices: Omit<OfferRequestSlice, 'origin_type' | 'destination_type'>[];
}
interface CreateOfferRequestQueryParameters {
    /**
     * When set to `true`, the offer request resource returned will include all the offers returned by the airlines.
     * If set to `false`, the offer request resource won't include any offers.
     * To retrieve the associated `offers` later, use the [List Offers](https://duffel.com/docs/api/offers/get-offers) endpoint, specifying the `offer_request_id`.
     * You should use this option if you want to take advantage of the pagination, sorting and filtering that the [List Offers](https://duffel.com/docs/api/offers/get-offers) endpoint provides.
     */
    return_offers?: boolean;
}

interface CreateOrderCancellation {
    /**
     * Duffel's unique identifier for the order
     */
    order_id: string;
}
interface ListOrderCancellationsParams extends PaginationMeta {
    /**
     * Duffel's unique identifier for the order, returned when it was created
     */
    order_id?: string;
}
interface OrderCancellation {
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime that indicates when the order cancellation was confirmed
     */
    confirmed_at: string;
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime at which the order cancellation was created
     */
    created_at: string;
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime by which this cancellation must be confirmed
     */
    expires_at: string;
    /**
     * Duffel's unique identifier for the order cancellation
     */
    id: string;
    /**
     * Whether the order cancellation was created in live mode. This field will be set to `true` if the order cancellation was created in live mode, or `false` if it was created in test mode.
     */
    live_mode: boolean;
    /**
     * Duffel's unique identifier for the order
     */
    order_id: string;
    /**
     * The amount that will be returned to the original payment method if the order is cancelled, determined according to the fare conditions. This may be `0.00` if the fare is non-refundable. It will include the refund amount of the flights and the services booked.
     */
    refund_amount: string;
    /**
     * The currency of the `refund_amount`, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code.
     * It will match your organisation's billing currency unless you're using Duffel as an accredited IATA agent, in which case it will be in the currency provided by the airline (which will usually be based on the country where your IATA agency is registered).
     * For pay later orders that are awaiting payment, the refund amount will always be 0.00.
     */
    refund_currency: string;
    /**
     * Where the refund, once confirmed, will be sent. `card` is currently a restricted feature. `awaiting_payment` is for pay later orders where no payment has been made yet.
     */
    refund_to: 'arc_bsp_cash' | 'balance' | 'card' | 'voucher' | 'awaiting_payment';
}

/**
 * @link https://duffel.com/docs/api/order-change-offers/schema
 */
interface OrderChangeOffer {
    /**
     * The price of this offer as a change to your existing order, excluding taxes
     */
    change_total_amount: string | null;
    /**
     * The currency of the change_total_amount, as an ISO 4217 currency code.
     * It will match your organisation's billing currency unless you're using Duffel
     * as an accredited IATA agent, in which case it will be in the currency provided
     * by the airline (which will usually be based on the country where your
     * IATA agency is registered).
     */
    change_total_currency: string | null;
    /**
     * The ISO 8601 datetime at which the offer was created
     */
    created_at: string;
    /**
     * The ISO 8601 datetime at which the offer will expire
     * and no longer be usable to create an order
     */
    expires_at: string;
    /**
     * Duffel's unique identifier for the order change offer
     */
    id: string;
    /**
     * The price of this offer if it was newly purchased, excluding taxes
     */
    new_total_amount: string | null;
    /**
     * The currency of the new_total_amount, as an ISO 4217 currency code.
     * It will match your organisation's billing currency unless you're using
     * Duffel as an accredited IATA agent, in which case it will be in the
     * currency provided by the airline (which will usually be based on the
     * country where your IATA agency is registered).
     */
    new_total_currency: string;
    /**
     * The ID for an order change if one has already been created from this order change offer
     */
    order_change_id: string;
    /**
     * The penalty price imposed by the airline for making this change
     */
    penalty_amount: string;
    /**
     * The currency of the penalty_amount, as an ISO 4217 currency code.
     * It will match your organisation's billing currency unless you're using
     * Duffel as an accredited IATA agent, in which case it will be in the
     * currency provided by the airline (which will usually be based on
     * the country where your IATA agency is registered).
     */
    penalty_currency: string;
    /**
     * Where the refund, once confirmed, will be sent. card is currently a restricted feature.
     * `awaiting_payment` is for pay later orders where no payment has been made yet.
     */
    refund_to: 'arc_bsp_cash' | 'balance' | 'card' | 'voucher' | 'awaiting_payment' | 'original_form_of_payment';
    /**
     * The slices to be added and/or removed
     */
    slices: OrderChangeOfferSlices;
    /**
     *  The ISO 8601 datetime at which the offer was last updated
     */
    updated_at: string;
}
interface OrderChangeOfferSlices {
    /**
     * The slices that will be added to the order
     */
    add: OrderChangeOfferSlice[];
    /**
     * The slices that will be removed from the order
     */
    remove: OrderChangeOfferSlice[];
}
interface OrderChangeOfferSlice {
    /**
     * The city or airport where this slice ends
     */
    destination: Place;
    /**
     * The type of the destination
     */
    destination_type: PlaceType;
    /**
     * The duration of the slice, represented as a [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) duration
     */
    duration?: string | null;
    /**
     * Duffel's unique identifier for the slice. It identifies the slice of an order (i.e. the same slice across orders will have different `id`s.
     */
    id: string;
    /**
     * The city or airport where this slice begins
     */
    origin: Place;
    /**
     * The type of the origin
     */
    origin_type: PlaceType;
    /**
     * The segments - that is, specific flights - that the airline is offering to get the passengers from the `origin` to the `destination`
     */
    segments: Array<Omit<OfferSliceSegment, 'passengers'>>;
}

interface OrderChangeSliceResponse {
    remove: {
        slice_id: string;
    };
    add: {
        /**
         * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date on which the passengers want to depart
         */
        departure_date: string;
        /**
         * The city or airport where this slice ends
         */
        destination: Place;
        /**
         * The city or airport where this slice begins
         */
        origin: Place;
        /**
         * The cabin that the passengers want to travel in
         */
        cabin_class: CabinClass;
    };
}
interface OrderChangeOffers$1 {
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime at which the offer was last updated
     */
    updated_at: string;
    /**
     * The price of this offer as a change to your existing order, excluding taxes
     */
    change_total_amount: string | null;
    /**
     * The currency of the `change_total_amount`, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code.
     * It will match your organisation's billing currency unless you're using Duffel as an accredited IATA agent, in which case it will be in the currency provided by the airline (which will usually be based on the country where your IATA agency is registered).
     */
    change_total_currency: string | null;
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime at which the offer was created
     */
    created_at: string;
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime at which the offer will expire and no longer be usable to create an order
     */
    expires_at: string;
    /**
     * Duffel's unique identifier for the order change offer
     */
    id: string;
    /**
     * The price of this offer if it was newly purchased, excluding taxes
     */
    new_total_amount: string | null;
    /**
     * The currency of the `new_total_amount`, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code. It will match your organisation's billing currency unless you're using Duffel as an accredited IATA agent, in which case it will be in the currency provided by the airline (which will usually be based on the country where your IATA agency is registered).
     */
    new_total_currency: string;
    /**
     * The ID for an `order change` if one has already been created from this `order change offer`
     */
    order_change_id: string;
    /**
     * The penalty price imposed by the airline for making this change
     */
    penalty_amount: string | null;
    /**
     * The currency of the `penalty_amount`, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code.
     * It will match your organisation's billing currency unless you're using Duffel as an accredited IATA agent, in which case it will be in the currency provided by the airline (which will usually be based on the country where your IATA agency is registered).
     */
    penalty_currency: string | null;
    /**
     * Where the refund, once confirmed, will be sent. `card` is currently a restricted feature. `awaiting_payment` is for pay later orders where no payment has been made yet.
     */
    refund_to: 'arc_bsp_cash' | 'balance' | 'card' | 'voucher' | 'awaiting_payment';
    /**
     * The slices within an order change that are being added to and/or removed from the order
     */
    slices: OrderChangeOfferSlices;
}
interface OrderChangeRequestResponse {
    /**
     * The ID of your order change request
     */
    id: string;
    /**
     * Whether the order was created in live mode. This field will be set to `true` if the order was created in live mode, or `false` if it was created in test mode.
     */
    live_mode: boolean;
    /**
     * The list of the offers available to perform change on the order.
     */
    order_change_offers: OrderChangeOffers$1[];
    /**
     * The order ID that you want to change
     */
    order_id: string;
    /**
     * The slices to be added and/or removed
     */
    slices: OrderChangeSliceResponse;
}
interface CreateOrderChangeRequest {
    /**
     * The changes you wish to make to your order
     */
    changes: {
        /**
         * The [slices](https://duffel.com/docs/api/overview/key-principles) that make up this offer request. One-way journeys can be expressed using one slice, whereas return trips will need two.
         */
        slices: {
            /**
             * The search criteria for slices which you wish to add to your order
             */
            add: {
                /**
                 * The cabin that the passengers want to travel in
                 */
                cabin_class: CabinClass;
                /**
                 * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date on which the passengers want to depart
                 */
                departure_date: string;
                /**
                 * The 3-letter IATA code for the city or airport where this slice ends
                 */
                destination: string;
                /**
                 * The 3-letter IATA code for the city or airport where this slice starts
                 */
                origin: string;
            }[];
            /**
             * The slices that you wish to remove from your order
             */
            remove: {
                slice_id: string;
            }[];
        };
    };
    /**
     * The order ID you wish to change
     */
    order_id: string;
}

interface OrderChange {
    /**
     * The price of this offer as a change to your existing order, excluding taxes
     */
    change_total_amount: string | null;
    /**
     * The currency of the change_total_amount, as an ISO 4217 currency code.
     * It will match your organisation's billing currency unless you're using Duffel
     * as an accredited IATA agent, in which case it will be in the currency provided
     * by the airline (which will usually be based on the country where your
     * IATA agency is registered).
     */
    change_total_currency: string | null;
    /**
     * Whether the order was created in live mode. This field will be set to `true`
     * if the order was created in live mode, or `false` if it was created in test mode.
     */
    live_mode: boolean;
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime at which the offer was created
     */
    created_at: string;
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime that indicates when the order change was confirmed
     */
    confirmed_at: string;
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime at which the offer will expire
     * and no longer be usable to create an order
     */
    expires_at: string;
    /**
     * Duffel's unique identifier for the order change offer
     */
    id: string;
    /**
     * The price of this offer if it was newly purchased, excluding taxes
     */
    new_total_amount: string | null;
    /**
     * The currency of the new_total_amount, as an ISO 4217 currency code.
     * It will match your organisation's billing currency unless you're using
     * Duffel as an accredited IATA agent, in which case it will be in the
     * currency provided by the airline (which will usually be based on the
     * country where your IATA agency is registered).
     */
    new_total_currency: string;
    /**
     * Duffel's unique identifier for the order which is being changed
     */
    order_id: string;
    /**
     * The penalty price imposed by the airline for making this change
     */
    penalty_amount: string | null;
    /**
     * The currency of the penalty_amount, as an ISO 4217 currency code.
     * It will match your organisation's billing currency unless you're using
     * Duffel as an accredited IATA agent, in which case it will be in the
     * currency provided by the airline (which will usually be based on
     * the country where your IATA agency is registered).
     */
    penalty_currency: string | null;
    /**
     * Where the refund, once confirmed, will be sent. card is currently a restricted feature.
     * `awaiting_payment` is for pay later orders where no payment has been made yet.
     */
    refund_to: 'arc_bsp_cash' | 'balance' | 'card' | 'voucher' | 'awaiting_payment' | 'original_form_of_payment';
    /**
     * The slices to be added and/or removed
     */
    slices: OrderChangeOfferSlices;
    /**
     * The available payment types to complete the order change.
     */
    available_payment_types?: PaymentType[] | null;
}
interface CreateOrderChangeParameters {
    /**
     * Duffel's unique identifier for the order change offer
     */
    selected_order_change_offer: string;
}
interface ConfirmOrderChangePayment {
    /**
     * The amount of the payment. This should be the same as the change_total_amount of the order change.
     */
    amount: string;
    /**
     * The currency of the change_total_amount, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code.
     */
    currency: string;
    /**
     * The type of payment you want to use for the Order Change.
     * If you are an IATA agent with your own agreements with airlines, in some cases, you can pay using ARC/BSP cash by specifying arc_bsp_cash.
     * Otherwise, you must pay using your Duffel account's balance by specifying balance.
     * In test mode, your balance is unlimited.
     * If you're not sure which of these options applies to you, get in touch with the Duffel support team at [help@duffel.com](mailto:help@duffel.com).
     */
    type: PaymentType;
}

/**
 * An object containing metadata about the service, like the designator of the seat.
 */
interface Seat {
    /**
     * The designator used to uniquely identify the seat, usually made up of a row number and a column letter
     * @example "14B"
     */
    designator: string;
    /**
     * Each disclosure is text, in English, provided by the airline that describes the terms and conditions of this seat. We recommend showing this in your user interface to make sure that customers understand any restrictions and limitations.
     * @example "["Do not seat children in exit row seats","Do not seat passengers with special needs in exit row seats"]"
     */
    disclosures: string[];
    /**
     * A name which describes the type of seat, which you can display in your user interface to help customers to understand its features
     * @example "Exit row seat"
     */
    name: string;
}
/**
 * An object containing metadata about the service, like the maximum weight and dimensions of the baggage.
 */
declare type OrderServiceBaggageMetadata = OfferAvailableServiceBaggageMetadata;
interface OrderSegmentPassengerBaggage {
    /**
     * The number of this type of bag allowed on the segment. Note that this can currently be 0 in some cases.
     */
    quantity: number;
    /**
     * The type of the baggage allowance
     */
    type: 'checked' | 'carry_on';
}
/**
 * Once you've searched for flights by creating an offer request, and you've chosen which offer you want to book, you'll then want to create an order.
 * @link https://duffel.com/docs/api/orders/schema
 */
interface OrderService {
    /**
     * Duffel's unique identifier for the booked service
     * @example "ser_00009UhD4ongolulWd9123"
     */
    id: string;
    /**
     * The metadata varies by the type of service. It includes further data about the service.
     * For example, for baggages, it may have data about size and weight restrictions.
     */
    metadata?: OrderServiceBaggageMetadata | Seat;
    /**
     * List of passenger ids the service applies to. The service applies to all the passengers in this list.
     * @example ["pas_00009hj8USM7Ncg31cBCLL"]
     */
    passenger_ids: string[];
    /**
     * The quantity of the service that was booked
     * @example 1
     */
    quantity: number;
    /**
     * List of segment `ids` the service applies to. The service applies to all the segments in this list.
     * @example "["seg_00009hj8USM7Ncg31cB456"]"
     */
    segment_ids: string[];
    /**
     * The total price of the service for all passengers and segments it applies to, accounting for quantity and including taxes
     * @example "15.00"
     */
    total_amount: string;
    /**
     * The currency of the `total_amount`, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code.
     * It will match your organisation's billing currency unless you're using Duffel as an accredited IATA agent, in which case it will be in the currency provided by the airline (which will usually be based on the country where your IATA agency is registered).
     * @example "GBP"
     */
    total_currency: string;
    /**
     * The type of the service.
     * For now we only return services of type `baggage` and `seat` but we will return other types in the future. We won't consider adding new service types a breaking change.
     */
    type: 'baggage' | 'seat';
}
interface OrderSegmentPassenger {
    /**
     * The baggage allowances for the passenger on this segment that were included in the original offer.
     * Any extra baggage items which were booked as services will be listed in the services field instead of here.
     */
    baggages: OrderSegmentPassengerBaggage[];
    /**
     * The cabin class that the passenger will travel in on this segment
     */
    cabin_class: CabinClass;
    /**
     * The name that the marketing carrier uses to market this cabin class
     */
    cabin_class_marketing_name: string;
    /**
     * The identifier for the passenger. You may have specified this ID yourself when creating the offer request, or otherwise, Duffel will have generated its own random ID.
     */
    passenger_id?: string;
    /**
     * An object containing metadata about the service, like the designator of the seat.
     */
    seat?: Seat;
}
interface OrderPassenger {
    id: string;
    /**
     * The passenger's date of birth
     * @example "1987-07-24"
     */
    born_on: string;
    /**
     * The passenger's family name
     * @example "Earheart"
     */
    family_name: string;
    /**
     * The passenger's given name
     * @xample "Amelia"
     */
    given_name: string;
    /**
     * The passenger's gender
     * @return "m" or "f"
     */
    gender: DuffelPassengerGender;
    /**
     * The passenger's title
     * @returns "mr", "ms", "mrs", or "miss"
     */
    title: DuffelPassengerTitle;
    /**
     * The type of the passenger
     * @return "adult", "child", or "infant_without_seat"
     */
    type: DuffelPassengerType;
    /**
     * The id of the infant associated with this passenger
     * @return "adult", "child", or "infant_without_seat"
     */
    infant_passenger_id?: string | null;
    /**
     * The **Loyalty Programme Accounts** for this passenger.
     */
    loyalty_programme_accounts?: LoyaltyProgrammeAccount[];
}
interface OrderPassengerIdentityDocument {
    /**
     * The type of the identity document. Currently, the only supported type is passport. This must be one of the allowed_passenger_identity_document_types on the offer.
     */
    type: PassengerIdentityDocumentType;
    /**
     * The unique identifier of the identity document
     */
    unique_identifier: string;
    /**
     * The ISO 3166-1 alpha-2 code of the country that issued this identity document
     */
    issuing_country_code: string;
    /**
     * The date on which the identity document expires
     */
    expires_on: string;
}
interface CreateOrderPassenger extends OrderPassenger {
    /**
     * The passenger's identity documents. You may only provide one identity document per passenger. The identity document's type must be included in the offer's allowed_passenger_identity_document_types. If the offer's passenger_identity_documents_required is set to true, then an identity document must be provided.
     */
    identity_documents: OrderPassengerIdentityDocument[];
    /**
     * The passenger's email address
     * @example "amelia@duffel.com"
     */
    email: string;
    /**
     * The passenger's phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) (international) format
     * @example "+442080160509"
     */
    phone_number: string;
}
interface OrderSliceSegment {
    /**
     * The aircraft that the operating carrier will use to operate this segment
     */
    aircraft?: Aircraft$1;
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime at which the segment is scheduled to arrive, in the destination airport timezone (see destination.timezone)
     */
    arriving_at: string;
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime at which the segment is scheduled to depart, in the origin airport timezone
     */
    departing_at: string;
    /**
     * The city or airport where this slice ends
     */
    destination: Place;
    /**
     * The terminal at the destination airport where the segment is scheduled to arrive
     * @example "5"
     */
    destination_terminal?: string | null;
    /**
     * The duration of the segment, represented as a [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) duration
     */
    duration?: string;
    /**
     * Duffel's unique identifier for the segment.
     * It identifies the segment of an order (i.e. the same segment across orders will have different ids.
     */
    id: string;
    /**
     * The airline selling the tickets for this segment. This may differ from the `operating_carrier` in the case of a "codeshare", where one airline sells flights operated by another airline.
     */
    marketing_carrier: Airline;
    /**
     * The flight number assigned by the marketing carrier
     * @example "1234"
     */
    marketing_carrier_flight_number: string;
    /**
     * The airline actually operating this segment. This may differ from the `marketing_carrier` in the case of a "codeshare", where one airline sells flights operated by another airline.
     */
    operating_carrier: Airline;
    /**
     * The flight number assigned by the operating carrier. This may not be present, in which case you should display the `marketing_carrier`'s information and the `marketing_carrier_flight_number`, and simply state the name of the `operating_carrier`.
     * @example "4321"
     */
    operating_carrier_flight_number: string;
    /**
     * The city or airport where this slice begins
     */
    origin: Place;
    /**
     * The terminal at the origin airport from which the segment is scheduled to depart
     * @example "B"
     */
    origin_terminal?: string | null;
    /**
     * Additional segment-specific information about the passengers included in the offer (e.g. their baggage allowance and the cabin class they will be travelling in)
     */
    passengers: OrderSegmentPassenger[];
    /**
     * The distance of the segment in kilometres
     * @example "424.2"
     */
    distance?: string | null;
}
interface OrderSlice {
    /**
     * Whether this slice can be changed. This can only be true for paid orders.
     */
    changeable: boolean | null;
    /**
     * The conditions associated with this slice, describing the kinds of modifications you can make and any penalties that will apply to those modifications.
     * This condition is applied only to this slice and to all the passengers associated with this order - for information at the order level (e.g. "what happens if I want to change all the slices?") refer to the `conditions` at the top level. If a particular kind of modification is allowed, you may not always be able to take action through the Duffel API. In some cases, you may need to contact the Duffel support team or the airline directly.
     */
    conditions: FlightsConditions;
    /**
     * The city or airport where this slice ends
     */
    destination: Place;
    /**
     * The type of the destination
     */
    destination_type: PlaceType;
    /**
     * The city or airport where this slice begins
     */
    origin: Place;
    /**
     * The type of the origin
     */
    origin_type: PlaceType;
    /**
     * Duffel's unique identifier for the slice. It identifies the slice of an order (i.e. the same slice across orders will have different ids.
     */
    id: string;
    /**
     * The duration of the slice, represented as a ISO 8601 duration
     */
    duration: string | null;
    /**
     * The segments - that is, specific flights - that the airline is offering to get the passengers from the origin to the destination
     */
    segments: OrderSliceSegment[];
}
interface OrderPaymentStatus {
    /**
     * Whether a payment has been made, or the airline is waiting for a payment to be made
     */
    awaiting_payment: boolean;
    /**
     *  The ISO 8601 datetime by which you must pay for this order.
     * At this time, if still unpaid, the reserved space on the flight(s)
     * will be released and you will have to create a new order.
     * This will be null only for orders where `awaiting_payment` is `false`.
     * Payment Required by means it will hold space
     */
    payment_required_by?: string;
    /**
     *  The ISO 8601 datetime at which the price associated
     * with the order will no longer be guaranteed by the airline
     * and the order will need to be repriced before payment.
     * This can be null when there is no price guarantee.
     * Price Guarantee means it will hold price
     */
    price_guarantee_expires_at?: string;
}
/**
 * The type of document
 * @returns "electronic_ticket", "electronic_miscellaneous_document_associated", or "electronic_miscellaneous_document_standalone"
 */
declare type OrderDocumentsType = 'electronic_ticket' | 'electronic_miscellaneous_document_associated' | 'electronic_miscellaneous_document_standalone';
interface OrderDocument {
    /**
     *  The identifier for the document, in the case of electronic
     *  tickets this string represents the payment or the entitlement to fly.
     * @example "1252106312810"
     */
    unique_identifier: string;
    /**
     * The type of document
     */
    type: OrderDocumentsType;
}
interface OrderPayment {
    /**
     * The type of payment you want to apply to the order.
     * If you are an IATA agent with your own agreements with airlines, in some cases, you can pay using ARC/BSP cash by specifying `arc_bsp_cash`.
     * Otherwise, you must pay using your Duffel account's `balance` by specifying balance. In test mode, your balance is unlimited.
     * If you're not sure which of these options applies to you, get in touch with the Duffel support team at [help@duffel.com](mailto:help@duffel.com).
     */
    type: PaymentType;
    /**
     * The amount of the payment. This should be the same as the `total_amount` of the offer specified in `selected_offers` for an instant order or the `total_amount` of the previously created pay later order specified in `order_id`, plus the `total_amount` of all the services specified in `services`.
     * @example "30.20"
     */
    amount: string;
    /**
     * The currency of the amount, as an ISO 4217 currency code. For an instant order, this should be the same as the total_currency of the offer specified in selected_offers. For a pay later order, this should be the same as the total_currency of the previously created order specified in order_id.
     * @example "GBP"
     */
    currency: string;
}
interface Order {
    /**
     * The amount of tax payable on the order for all the flights booked
     */
    tax_amount?: string;
    /**
     * The currency of the `tax_amount`, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code
     */
    tax_currency: string;
    /**
     * The total price of the order for all the flights and services booked, including taxes
     */
    total_amount: string;
    /**
     * The currency of the `total_amount`, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code
     */
    total_currency: string;
    /**
     * The [slices](https://duffel.com/docs/api/overview/key-principles) that make up the itinerary of this order.
     * One-way journeys can be expressed using one slice,
     * whereas return trips will need two.
     */
    slices: OrderSlice[];
    /**
     * The services booked along with this order
     */
    services: OrderService[];
    /**
     * The passengers who are travelling
     */
    passengers: OrderPassenger[];
    /**
     * The payment status for this order
     *
     */
    payment_status: OrderPaymentStatus;
    /**
     * The airline who owns the order
     */
    owner: Airline;
    /**
     * Whether the order was created in live mode.
     * This field will be set to true if the order was created
     * in live mode, or false if it was created in test mode.
     */
    live_mode: boolean;
    /**
     * Duffel's unique identifier for the order
     */
    id: string;
    /**
     *  The documents issued for this order.
     */
    documents?: OrderDocument[];
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) datetime at which the order was created
     */
    created_at: string;
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) datetime at which the order was cancelled, if it has been cancelled
     */
    cancelled_at?: string | null;
    /**
     * The airline's reference for the order, sometimes known as a
     * "passenger name record" (PNR) or "record locator".
     * Your customers can use this to check in and manage
     * their booking on the airline's website.
     */
    booking_reference: string;
    /**
     * The currency of the base_amount, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code.
     * It will match your organisation's billing currency unless you're
     * using Duffel as an accredited IATA agent, in which case it will
     * be in the currency provided by the airline (which will usually
     * be based on the country where your IATA agency is registered).
     */
    base_currency: string;
    /**
     *  The base price of the order for all flights and services booked, excluding taxes
     */
    base_amount: string;
    /**
     * The conditions associated with this order, describing the kinds of modifications you can make post-booking and any penalties that will apply to those modifications.
     *
     * This information assumes the condition is applied to all of the slices and passengers associated with this order - for information at the slice level (e.g. "what happens if I just want to change the first slice?") refer to the `slices`.
     *
     * If a particular kind of modification is allowed, you may not always be able to take action through the Duffel API.
     *
     * In some cases, you may need to contact the Duffel support team or the airline directly.
     */
    conditions: FlightsConditions;
    /**
     * Metadata contains a set of key-value pairs that you can attach to an object.
     * It can be useful for storing additional information about the object, in a structured format.
     * Duffel does not use this information.
     * You should not store sensitive information in this field.
     */
    metadata: Record<string, string>;
}
interface CreateOrder {
    /**
     * The `id`s of the offers you want to book. You must specify an array containing exactly one selected offer.
     */
    selected_offers: string[];
    /**
     * The services you want to book along with the first selected offer.
     */
    services?: Pick<OrderService, 'id' | 'quantity'>[];
    /**
     * The personal details of the passengers, expanding on the information initially provided when creating the offer request
     */
    passengers: CreateOrderPassenger[];
    /**
     * The payment details to use to pay for the order
     */
    payments?: OrderPayment[];
    /**
     * The payment action you want to take for your order. You can only use pay_later with offers that contain requires_instant_payment: false.
     */
    type: 'instant' | 'pay_later';
}
interface ListParamsOrders {
    /**
     * Whether to filter orders that are awaiting payment or not. If not specified, all orders regardless of their payment state will be returned.
     */
    awaiting_payment?: boolean;
    /**
     * Whether to filter orders matching a passenger name. Partial and exact matches in given and family names will be returned.
     */
    'passenger_name[]'?: string[];
    /**
     * Whether to filter orders matching a given passenger name record (PNR)
     */
    booking_reference?: string;
}
interface UpdateSingleOrder {
    metadata: Order['metadata'];
}

/**
 * To pay for an unpaid order you've previously created, you'll need to create a payment for it.
 * @link https:/duffel.com/docs/api/payments/schema
 */
interface Payment {
    /**
     * The amount of the payment.
     * This should be the same as the `total_amount` of the offer specified in `selected_offers` for an instant order or the `total_amount` of the previously created pay later order specified in `order_id`, plus the `total_amount` of all the services specified in services.
     */
    amount: string;
    /**
     * The currency of the amount, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code.
     * For an instant order, this should be the same as the `total_currency` of the offer specified in selected_offers.
     * For a pay later order, this should be the same as the `total_currency` of the previously created order specified in `order_id`.
     */
    currency?: string | null;
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime at which the payment was created
     */
    created_at: string;
    /**
     * Duffel's unique identifier for the payment
     */
    id: string;
    /**
     * The type of payment you want to apply to the order.
     * If you are an IATA agent with your own agreements with airlines, in some cases, you can pay using ARC/BSP cash by specifying `arc_bsp_cash`.
     * Otherwise, you must pay using your Duffel account's balance by specifying `balance`. In [test mode](https://duffel.com/docs/api/overview/test-mode), your balance is unlimited.
     * If you're not sure which of these options applies to you, get in touch with the Duffel support team at [help@duffel.com](mailto:help@duffel.com).
     */
    type: PaymentType;
}
interface CreatePayment {
    /**
     * The `id` of the order you want to pay for.
     */
    order_id: string;
    /**
     * The payment details to use to pay for the order
     */
    payment: Omit<Payment, 'created_at' | 'id'>;
}

/**
 * Seat maps are used to build a rich experience for your customers so they can select a seat as part of an order.
 * A seat map includes the data for rendering seats in the relevant cabins, along with their total cost and other information such as disclosures.
 * @link https://duffel.com/docs/api/seat-maps/schema
 */
interface SeatMap {
    /**
     * Duffel's unique identifier for the seat map
     */
    id: string;
    /**
     * Duffel's unique identifier for the slice. It identifies the slice of an offer (i.e. the same slice across offers will have different ids.)
     */
    slice_id: string;
    /**
     * Duffel's unique identifier for the segment. It identifies the segment of an offer (i.e. the same segment across offers will have different ids).
     */
    segment_id: string;
    /**
     * The list of cabins in this seat map.
     * Cabins are ordered by deck from lowest to highest, and then within each deck from the front to back of the aircraft.
     */
    cabins: SeatMapCabin[];
}
interface SeatMapCabin {
    /**
     * Level 0 is the main deck and level 1 is the upper deck above that, which is found on some large aircraft.
     */
    deck: number;
    /**
     * The cabin class that the passenger will travel in on this segment
     */
    cabin_class: string;
    /**
     * Where the wings of the aircraft are in relation to rows in the cabin.
     * The numbers correspond to the indices of the first and the last row which are overwing. You can use this to draw a visual representation of the wings to help users get a better idea of what they will see outside their window.
     * The indices are 0 th-based and are for all rows, not just those that have seats.
     * This is null when no rows of the cabin are overwing.
     */
    wings: {
        /**
         * The index of the first row which is overwing, starting from the front of the aircraft.
         */
        first_row_index: number;
        /**
         * The index of the last row which is overwing, starting from the front of the aircraft.
         */
        last_row_index: number;
    } | null;
    /**
     * The number of aisles in this cabin.
     * If this is set to 1, each row of the cabin is split into two sections. If this is set to 2, each row of the cabin is split into three section.
     */
    aisles: number;
    /**
     * A list of rows in this cabin.
     * Row sections are broken up by aisles. Rows are ordered from front to back of the aircraft.
     */
    rows: SeatMapCabinRow[];
}
interface SeatMapCabinRow {
    /**
     * A list of sections.
     * Each row is divided into sections by one or more aisles.
     */
    sections: SeatMapCabinRowSection[];
}
interface SeatMapCabinRowSection {
    /**
     * The elements that make up this section.
     */
    elements: SeatMapCabinRowSectionElement[];
}
/**
 * A seat for a passenger. If the available_services list is empty (which will be represented as an empty list : []), the seat is unavailable.
 * For display, all seats should be displayed with the same static width.
 */
interface SeatMapCabinRowSectionElementSeat {
    /**
     * The type of this element.
     */
    type: 'seat';
    /**
     * The designator used to uniquely identify the seat, usually made up of a row number and a column letter
     */
    designator: string;
    /**
     * A name which describes the type of seat, which you can display in your user interface to help customers to understand its features
     */
    name?: string;
    /**
     * Each disclosure is text, in English, provided by the airline that describes the terms and conditions of this seat. We recommend showing this in your user interface to make sure that customers understand any restrictions and limitations.
     */
    disclosures: string[];
    /**
     * Seats are considered a special kind of service. There will be at most one service per seat per passenger. A seat can only be booked for one passenger. If a seat has no available services (which will be represented as an empty list : []) then it's unavailable.
     */
    available_services: SeatMapCabinRowSectionAvailableService[];
}
interface SeatMapCabinRowSectionAvailableService {
    /**
     * Duffel's unique identifier for the service
     */
    id: string;
    /**
     * The passenger that this seat is for
     */
    passenger_id: string;
    /**
     * The total price of the seat, including taxes
     */
    total_amount: string;
    /**
     * The currency of the total_amount, as an ISO 4217 currency code
     */
    total_currency: string;
}
/**
 * A bassinet is a child's cradle. This element will be aligned with the corresponding seat in the following row.
 * For display, this element should have the same width as a seat for proper alignment.
 */
interface SeatMapCabinRowSectionElementBassinet {
    /**
     * The type of this element.
     */
    type: 'bassinet';
}
/**
 * An empty space used for padding in some non-standard seat arrangements.
 * For display, this element should have the same dimensions as a seat for proper alignment.
 */
interface SeatMapCabinRowSectionElementEmpty {
    /**
     * The type of this element.
     */
    type: 'empty';
}
/**
 * An exit row represents the extra wide legroom used to reach aircraft exits. There is one exit_row element per row section.
 * Exit row elements only occur in their own row, so they can be displayed as one element across the whole row. Displaying an exit row element filling all available space in its section or using the same width as the seat is also reasonable.
 */
interface SeatMapCabinRowSectionElementExitRow {
    /**
     * The type of this element.
     */
    type: 'exit_row';
}
/**
 * A lavatory for use by passengers.
 * For display, this element should ideally fill or shrink to available space in a row section. Displaying it with the same width as seat is also reasonable.
 */
interface SeatMapCabinRowSectionElementLavatory {
    /**
     * The type of this element.
     */
    type: 'lavatory';
}
/**
 * A galley is the compartment where food is cooked or prepared. These are conventionally marked with a teacup symbol.
 * For display, this element should ideally fill or shrink to available space in a row section. Displaying it with the same width as seat is also reasonable.
 */
interface SeatMapCabinRowSectionElementGalley {
    /**
     * The type of this element.
     */
    type: 'galley';
}
/**
 * A closet used for storage. These are conventionally marked with a clothes hanger symbol.
 * For display, this element should ideally fill or shrink to available space in a row section. Displaying it with the same width as seat is also reasonable.
 */
interface SeatMapCabinRowSectionElementCloset {
    /**
     * The type of this element.
     */
    type: 'closet';
}
/**
 * A set of stairs to another deck.
 * For display, this element should ideally fill or shrink to available space in a row section. Displaying it with the same width as seat is also reasonable.
 */
interface SeatMapCabinRowSectionElementStairs {
    /**
     * The type of this element.
     */
    type: 'stairs';
}
declare type SeatMapCabinRowSectionElement = SeatMapCabinRowSectionElementSeat | SeatMapCabinRowSectionElementBassinet | SeatMapCabinRowSectionElementEmpty | SeatMapCabinRowSectionElementExitRow | SeatMapCabinRowSectionElementLavatory | SeatMapCabinRowSectionElementGalley | SeatMapCabinRowSectionElementCloset | SeatMapCabinRowSectionElementStairs;
declare type SeatMapCabinRowSectionElementType = SeatMapCabinRowSectionElement['type'];
declare type SeatMapCabinRowSectionElementAmenity = Exclude<SeatMapCabinRowSectionElementType, 'empty' | 'seat'>;

/**
 * Aircraft are used to describe what passengers will fly in for a given trip
 * @link https://duffel.com/docs/api/aircraft/schema
 */
interface Aircraft$1 {
    /**
     * The name of the aircraft
     */
    name: string;
    /**
     * Duffel's unique identifier for the aircraft
     */
    id: string;
    /**
     * The three-character IATA code for the aircraft
     */
    iata_code: string;
}

/**
 * Airlines are used to identify the air travel companies selling and operating flights
 * @link https://duffel.com/docs/api/airlines/schema
 */
interface Airline {
    /**
     * The three-character IATA code for the airline
     */
    name: string;
    /**
     * Duffel's unique identifier for the airline
     */
    id: string;
    iata_code: string;
}

/**
 * Airports are used to identify origins and destinations in journey slices
 * @link https://duffel.com/docs/api/airports/schema
 */
interface Airport {
    /**
     * The metropolitan area where the airport is located.
     * Only present for airports which are registered with IATA as belonging to a metropolitan area.
     */
    city?: City | null;
    /**
     * The name of the city (or cities separated by a `/`) where the airport is located
     */
    city_name: string;
    /**
     * The three-character IATA code for the airport
     */
    iata_code?: string;
    /**
     * The ISO 3166-1 alpha-2 code for the country where the city is located
     * @link https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
     * @example "GB"
     */
    iata_country_code: string;
    /**
     * The 3-letter IATA code for the city where the place is located.
     * Only present for airports which are registered with IATA as belonging to a [metropolitan area](https://portal.iata.org/faq/articles/en_US/FAQ/How-do-I-create-a-new-Metropolitan-Area).
     */
    iata_city_code?: string | null;
    /**
     * The four-character ICAO code for the airport
     */
    icao_code?: string;
    /**
     * Duffel's unique identifier for the airport
     */
    id: string;
    /**
     * The latitude position of the airport represented in Decimal degrees with 6 decimal points with a range between -90° and 90°
     */
    latitude: number;
    /**
     * The longitude position of the airport represented in Decimal degrees with 6 decimal points with a range between -180° and 180°
     */
    longitude: number;
    /**
     * The name of the airport
     */
    name: string;
    /**
     * The time zone of the airport, specified by name from the [tz database](https://en.wikipedia.org/wiki/Tz_database)
     */
    time_zone: string;
}

interface PaymentIntent {
    /**
     * The amount of the Payment Intent that covers the cost of the flight being sold and any additional markup.
     * The card payment will be charged this amount.
     */
    amount: string;
    /**
     * The [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code of the country that issued the card used to confirm the Payment Intent.
     * It will be null until the Payment Intent is confirmed.
     */
    card_country_code: string | null;
    /**
     * The last four digits of the card used to confirm the Payment Intent.
     * It will be null until the Payment Intent is confirmed.
     */
    card_last_four_digits: string | null;
    /**
     * The card network in which the Payment Intent was processed on.
     * It will be null until the Payment Intent is confirmed.
     */
    card_network: 'amex' | 'cartes_bancaires' | 'diners' | 'discover' | 'interac' | 'jcb' | 'mastercard' | 'unionpay' | 'visa' | 'unknown' | null;
    /**
     * This value is used when displaying the payment collection form to securely identify and transmit the values to Duffel.
     */
    client_token: string;
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime at which the Payment Intent was confirmed
     */
    confirmed_at: string;
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime at which the Payment Intent was created
     */
    created_at: string;
    /**
     * The currency of the `amount`, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code.
     * The card payment will be charged in this currency.
     * If it's different to your Balance currency, it will be converted to your Balance currency before the Balance is topped up.
     */
    currency: string;
    /**
     * The amount of the fees to process the Payment Intent.
     * It will be `null` until the Payment Intent is confirmed.
     */
    fees_amount: string | null;
    /**
     * The currency of the fees_amount, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code.
     * This currency will match your Balance currency.
     * It will be null until the Payment Intent is confirmed.
     */
    fees_currency: string | null;
    /**
     * Duffel's unique identifier for the `Payment Intent`
     */
    id: string;
    /**
     * Whether the Payment Intent was created in live mode. This field will be set to `true` if the Payment Intent was created in live mode, or `false` if it was created in test mode.
     */
    live_mode: boolean;
    /**
     * The amount of the Payment Intent that was added to the Balance.
     * It'll be `amount` (in the Balance currency) less the `fees_amount`.
     * It will be `null` until the Payment Intent is confirmed.
     */
    net_amount: string | null;
    /**
     * The currency of the net_amount, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code.
     * This currency will match your Balance currency.
     * It will be null until the Payment Intent is confirmed.
     */
    net_currency: string | null;
    /**
     * The Refunds for this Payment Intent
     * @link https://duffel.com/docs/api/payment-intents/schema#payment-intents-schema-refunds
     */
    refunds: {
        amount: string;
        arrival: string;
        created_at: string;
        currency: string;
        destination: string;
        id: string;
        live_mode: boolean;
        net_amount: string;
        net_currency: string;
        payment_intent_id: string;
        status: 'succeeded' | 'pending' | 'failed';
        updated_at: string;
    }[];
    /**
     * The status of this Payment Intent
     */
    status: null | 'requires_payment_method' | 'requires_confirmation' | 'requires_action' | 'processing' | 'requires_capture' | 'cancelled' | 'succeeded';
    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime at which the Payment Intent was updated
     */
    updated_at: string;
}
interface CreatePaymentIntent {
    /**
     * This is the amount that the card payment being taken will be charged.
     * It should be enough to cover the service(s) you want to sell (enough to book an Offer for example) and the processing fees.
     * If the currency is different from your Balance currency you should also account for foreign exchange.
     * It can be higher than that, in which case the remainder will be considered your markup.
     * If it's higher than the maximum allowed for you organisation you will get a validation error. By default the maximum is 5,000.00 GBP (or equivalent in the same currency). If you need a maximum higher than the default please get in touch with us via help@duffel.com.
     */
    amount: string;
    /**
     * The currency of the amount, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code.
     * This is going to be the currency that the card payment being taken in will be charged in.
     */
    currency: string;
}

/**
 * The metropolitan area where the airport is located.
 * Only present for airports which are registered with IATA as belonging to a metropolitan area.
 * @link https://portal.iata.org/faq/articles/en_US/FAQ/How-do-I-create-a-new-Metropolitan-Area
 */
interface City {
    /**
     * The type of the place
     */
    type?: 'city';
    /**
     * The three-character IATA code for the city
     * @example "LON"
     */
    iata_code: string;
    /**
     * The ISO 3166-1 alpha-2 code for the country where the city is located
     * @link https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
     * @example "GB"
     */
    iata_country_code: string;
    /**
     * Duffel's unique identifier for the city
     * @example "cit_lon_gb"
     */
    id: string;
    /**
     * The name of the city
     * @example "London"
     */
    name: string;
    /**
     * The time zone of the airport, specified by name from the [tz database](https://en.wikipedia.org/wiki/Tz_database)
     */
    time_zone?: string | null;
    /**
     * The longitude position of the airport represented in [Decimal degrees](https://en.wikipedia.org/wiki/Decimal_degrees) with 6 decimal points with a range between -180° and 180°
     */
    longitude?: number | null;
    /**
     * The latitude position of the airport represented in [Decimal degrees](https://en.wikipedia.org/wiki/Decimal_degrees) with 6 decimal points with a range between -90° and 90°
     */
    latitude?: number | null;
    /**
     * The 3-letter IATA code for the city where the place is located.
     * Only present for airports which are registered with IATA as belonging to a [metropolitan area](https://portal.iata.org/faq/articles/en_US/FAQ/How-do-I-create-a-new-Metropolitan-Area).
     */
    iata_city_code?: string | null;
    /**
     * The name of the city (or cities separated by a `/`) where the airport is located
     */
    city_name?: string | null;
}
/**
 * The cabin class that the passenger will travel in on this segment
 */
declare type CabinClass = 'first' | 'business' | 'premium_economy' | 'economy';
/**
 * The type of the passenger
 */
declare type DuffelPassengerType = 'adult' | 'child' | 'infant_without_seat';
/**
 * The passenger's title
 */
declare type DuffelPassengerTitle = 'mr' | 'ms' | 'mrs' | 'MR' | 'MS' | 'MRS';
/**
 * The passenger's gender
 */
declare type DuffelPassengerGender = 'm' | 'f';
/**
 * The type of the identity document. Currently, the only supported type is passport.
 * This must be one of the `allowed_passenger_identity_document_types` on the offer.
 */
declare type PassengerIdentityDocumentType = 'passport';
/**
 * The type of the origin or destination
 */
declare type PlaceType = 'airport' | 'city';
declare type Place = (Airport & {
    type?: 'airport';
    airports?: Airport[] | null;
}) | (City & {
    type?: 'city';
});
/**
 * The conditions associated with this offer, describing the kinds of modifications you can make post-booking and any penalties that will apply to those modifications.
 * This information assumes the condition is applied to all of the slices and passengers associated with this offer - for information at the slice level (e.g. "what happens if I just want to change the first slice?") refer to the slices.
 * If a particular kind of modification is allowed, you may not always be able to take action through the Duffel API.
 * In some cases, you may need to contact the Duffel support team or the airline directly.
 */
declare type FlightsConditions = {
    /**
     * Whether the whole order or offer can be refunded before the departure of the first slice.
     * If all of the slices on the order or offer can be refunded then the `allowed` property will be `true` and information will be provided about any penalties.
     * If any of the slices on the order or offer can't be refunded then the `allowed` property will be `false`.
     * If the airline hasn't provided any information about whether this order or offer can be refunded then this property will be `null`.
     */
    refund_before_departure?: {
        /**
         * The currency of the `penalty_amount` as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code.
         * This will be in a currency determined by the airline, which is not necessarily the same as the currency of the order or offer.
         * If this is `null` then `penalty_amount` will also be `null`.
         * @example "GBP"
         */
        penalty_currency: string;
        /**
         * If the modification is `allowed` then this is the amount payable to apply the modification to all passengers.
         * If there is no penalty, the value will be zero. If the modification isn't `allowed` or the penalty is not known then this field will be `null`.
         * If this is `null` then the `penalty_currency` will also be null.
         * @example "100.00"
         */
        penalty_amount?: string;
        /**
         * Whether this kind of modification is allowed post-booking
         *
         * @example "true"
         */
        allowed: boolean;
    } | null;
    /**
     * Whether the whole order or offer can be changed before the departure of the first slice.
     * If all of the slices on the order or offer can be changed then the `allowed` property will be `true`.
     * Refer to the `slices` for information about change penalties.
     * If any of the slices on the order or offer can't be changed then the `allowed` property will be `false`.
     * In this case you should refer to the slices conditions to determine if any part of the order or offer is changeable.
     * If the airline hasn't provided any information about whether this order or offer can be changed then this property will be `null`.
     */
    change_before_departure?: {
        /**
         * The currency of the `penalty_amount` as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code.
         * This will be in a currency determined by the airline, which is not necessarily the same as the currency of the order or offer.
         * If this is `null` then `penalty_amount` will also be `null`.
         * @example "GBP"
         */
        penalty_currency: string;
        /**
         * If the modification is `allowed` then this is the amount payable to apply the modification to all passengers.
         * If there is no penalty, the value will be zero. If the modification isn't `allowed` or the penalty is not known then this field will be `null`.
         * If this is `null` then the `penalty_currency` will also be null.
         * @example "100.00"
         */
        penalty_amount?: string;
        /**
         * Whether this kind of modification is allowed post-booking
         *
         * @example "true"
         */
        allowed: boolean;
    } | null;
};
/**
 * The type of payment you want to apply to the order.
 * If you are an IATA agent with your own agreements with airlines, in some cases, you can pay using ARC/BSP cash by specifying `arc_bsp_cash`. Otherwise, you must pay using your Duffel account's balance by specifying `balance`.
 * In test mode, your balance is unlimited. If you're not sure which of these options applies to you, get in touch with the Duffel support team at [help@duffel.com](mailto:help@duffel.com).
 */
declare type PaymentType = 'arc_bsp_cash' | 'balance';

/**
 * Our list APIs will only return a limited number of results at a time.
 * By default, we'll return 50 results per page, but you can set this to any number between 1 and 200.
 * @link https://duffel.com/docs/api/overview/pagination
 */
interface PaginationMeta {
    /**
     * The number of results to be returned in a page, between 1 and 200 (optional, default is 50)
     */
    limit?: number;
    /**
     * "Before" cursor for pagination
     */
    before?: string;
    /**
     * "After" cursor for pagination
     */
    after?: string | null;
}
interface ApiResponseMeta {
    /**
     * The identifier of the request
     */
    request_id: string;
    /**
     * The [HTTP status](https://httpstatuses.com/) of the request
     */
    status: number;
}
/**
 * Duffel uses standard [HTTP response codes](https://httpstatuses.com/) to indicate the success or failure of API requests.
 * @link https://duffel.com/docs/api/overview/errors
 */
interface ApiResponseError {
    /**
     * A machine-readable identifier for this specific error
     */
    code: string;
    /**
     * A URL pointing to a place in our documentation where you can read about the error
     */
    documentation_url: string;
    /**
     * A more detailed human-readable description of what went wrong
     */
    message: string;
    /**
     * A quick and simple description of what went wrong
     */
    title: string;
    /**
     * A machine-readable identifier for the general category of error
     */
    type: string;
}
interface DuffelResponse<T_Data> {
    /**
     * The body of the response
     */
    data: T_Data;
    /**
     * Optional metadata for the request
     */
    meta?: PaginationMeta;
}
declare class DuffelError extends Error {
    meta: ApiResponseMeta;
    errors: ApiResponseError[];
    constructor({ meta, errors, }: {
        meta: ApiResponseMeta;
        errors: ApiResponseError[];
    });
}
interface SDKOptions {
    /**
     * If `true` it will output the path and the method called
     */
    verbose?: boolean;
}

interface Config {
    token: string;
    basePath?: string;
    apiVersion?: string;
    debug?: SDKOptions;
}
declare class Client {
    private token;
    private basePath;
    private apiVersion;
    private debug;
    constructor({ token, basePath, apiVersion, debug }: Config);
    request: <T_Data = any>({ method, path, data, params, compress, }: {
        method: string;
        path: string;
        data?: Record<string, any> | undefined;
        params?: Record<string, any> | undefined;
        compress?: boolean | undefined;
    }) => Promise<DuffelResponse<T_Data>>;
    paginatedRequest<T_Data = any>({ path, params, }: {
        path: string;
        params?: Record<string, any>;
    }): AsyncGenerator<DuffelResponse<T_Data>, void, unknown>;
}

declare class Resource {
    private client;
    constructor(client: Client);
    protected request: <T_Data = any>({ method, path, data, params, }: {
        method: string;
        path: string;
        data?: Record<string, any> | undefined;
        params?: Record<string, any> | undefined;
    }) => Promise<DuffelResponse<T_Data>>;
    protected paginatedRequest: <T_Data = any>({ path, params, }: {
        path: string;
        params?: Record<string, any> | undefined;
    }) => AsyncGenerator<DuffelResponse<T_Data>, void, unknown>;
}

declare class PaymentIntents extends Resource {
    /**
     * Endpoint path
     */
    path: string;
    constructor(args: any);
    /**
     * You should use this API to get the complete, up-to-date information about a Payment Intent.
     * @param {string} id - Duffel's unique identifier for the Payment Intent
     * @link https://duffel.com/docs/api/payment-intents/get-payment-intent-by-id
     */
    get: (id: string) => Promise<DuffelResponse<PaymentIntent>>;
    /**
     * Once you've successfully collected the customer's card details, using the `client_token` from when you first created the Payment Intent, you then need to confirm it using this endpoint.
     * Once confirmed, the amount charged to your customer's card will be added to your `Balance` (minus any Duffel Payment fees).
     */
    confirm: (id: string) => Promise<DuffelResponse<PaymentIntent>>;
    /**
     * To begin the process of collecting a card payment from your customer, you need to create a Payment Intent.
     * The Payment Intent will contain a `client_token` that you use to collect the card payment in your application.
     * If the Payment Intent is created in test mode you should use a [test card](https://duffel.com/docs/api/overview/test-mode/test-card-numbers).
     * @param {Object.<CreatePaymentIntent>} params - Endpoint params (amount and string)
     */
    create: (params: CreatePaymentIntent) => Promise<DuffelResponse<PaymentIntent>>;
}

/**
 * To search for flights, you'll need to create an `offer request`.
 * An offer request describes the passengers and where and when they want to travel (in the form of a list of `slices`).
 * It may also include additional filters (e.g. a particular cabin to travel in).
 * @class
 * @link https://duffel.com/docs/api/offer-requests
 */
declare class OfferRequests extends Resource {
    /**
     * Endpoint path
     */
    path: string;
    constructor(client: Client);
    /**
     * Retrieves an offer request by its ID
     * @param {string} id - Duffel's unique identifier for the offer request
     * @link https:/duffel.com/docs/api/offer-requests/get-offer-request-by-id
     */
    get: (id: string) => Promise<DuffelResponse<OfferRequest>>;
    /**
     * Retrieves a page of offer requests. The results may be returned in any order.
     * @param {Object} [options] - Pagination options (optional: limit, after, before)
     * @link https://duffel.com/docs/api/offer-requests/get-offer-requests
     */
    list: (options?: PaginationMeta | undefined) => Promise<DuffelResponse<OfferRequest[]>>;
    /**
     * Retrieves a generator of all offer requests. The results may be returned in any order.
     * @link https://duffel.com/docs/api/offer-requests/get-offer-requests
     */
    listWithGenerator: () => AsyncGenerator<DuffelResponse<OfferRequest>, void, unknown>;
    /**
     * To search for flights, you'll need to create an `offer request`.
     * An offer request describes the passengers and where and when they want to travel (in the form of a list of `slices`).
     * It may also include additional filters (e.g. a particular cabin to travel in).
     * @param {Object} [options] - the parameters for making an offer requests (required: slices, passengers; optional: cabin_class, return_offers)
     * When `return_offers` is set to `true`, the offer request resource returned will include all the `offers` returned by the airlines.
     * If set to false, the offer request resource won't include any `offers`. To retrieve the associated offers later, use the List Offers endpoint, specifying the `offer_request_id`.
     * @link https://duffel.com/docs/api/offer-requests/create-offer-request
     */
    create: <QueryParams extends CreateOfferRequestQueryParameters>(options: CreateOfferRequest & QueryParams) => Promise<DuffelResponse<QueryParams extends {
        return_offers: false;
    } ? Omit<OfferRequest, "offers"> : OfferRequest>>;
}

interface UpdateOfferBodyParameters {
    loyalty_programme_accounts: LoyaltyProgrammeAccounts[];
    given_name: string;
    family_name: string;
}
/**
 * Each offer represents flights you can buy from an airline at a particular price that meet your search criteria.
 * @class
 * @link https://duffel.com/docs/api/offers
 */
declare class Offers extends Resource {
    /**
     * Endpoint path
     */
    path: string;
    constructor(client: Client);
    /**
     * Retrieves an offer by its ID
     * @param {string} id - Duffel's unique identifier for the offer
     * @param {string} return_available_services - When set to true, the offer resource returned will include all the available_services returned by the airline. If set to false, the offer resource won't include any available_services.
     * @link https:/duffel.com/docs/api/offers/get-offer-by-id
     */
    get: (id: string, params?: {
        return_available_services: boolean;
    } | undefined) => Promise<DuffelResponse<Offer>>;
    /**
     * Retrieves a page of offers. The results may be returned in any order.
     * @param {Object.<ListOffersParams>} params - Endpoint options (optional: limit, after, before, max_connections, sort)
     * @param {string} params.offer_request_id - Duffel's unique identifier for the offer request, returned when it was created
     * @link https://duffel.com/docs/api/offers/get-offers
     */
    list: ({ offer_request_id, ...params }: ListOffersParams) => Promise<DuffelResponse<Offer[]>>;
    /**
     * Retrieves a generator of all offers. The results may be returned in any order.
     * @param {Object.<ListOffersParams>} params - Endpoint options (optional: limit, after, before, max_connections, sort)
     * @param {string} params.offer_request_id - Duffel's unique identifier for the offer request, returned when it was created
     * @link https://duffel.com/docs/api/offers/get-offers
     */
    listWithGenerator: ({ offer_request_id, ...params }: ListOffersParams) => AsyncGenerator<DuffelResponse<Offer>, void, unknown>;
    /**
     * Some offer passenger fields are updateable. Each field that can be updated is detailed in the request object.
     * @param {string} offerId - Duffel's unique identifier for the offer
     * @param {string} passengerId - The identifier for the passenger. This ID will be generated by Duffel
     * @param {string} params.family_name - The passenger's family name. Only space, -, ', and letters from the ASCII, Latin-1 Supplement and Latin Extended-A (with the exceptions of Æ, æ, Ĳ, ĳ, Œ, œ, Þ, and ð) Unicode charts are accepted. All other characters will result in a validation error. The minimum length is 1 character, and the maximum is 20 characters.
     * @param {string} params.given_name - The passenger's given name. Only space, -, ', and letters from the ASCII, Latin-1 Supplement and Latin Extended-A (with the exceptions of Æ, æ, Ĳ, ĳ, Œ, œ, Þ, and ð) Unicode charts are accepted. All other characters will result in a validation error. The minimum length is 1 character, and the maximum is 20 characters.
     * @param {Object.<LoyaltyProgrammeAccounts>} params.loyalty_programme_accounts - The Loyalty Programme Accounts for this passenger
     */
    update: (offerId: string, passengerId: string, params: UpdateOfferBodyParameters) => Promise<DuffelResponse<UpdateOffer>>;
}

declare class OrderCancellations extends Resource {
    /**
     * Endpoint path
     */
    path: string;
    constructor(args: any);
    /**
     * Retrieves an order cancellation by its ID
     * @param {string} id - Duffel's unique identifier for the order cancellation
     * @link https:/duffel.com/docs/api/order-cancellations/get-order-cancellation-by-id
     */
    get: (id: string) => Promise<DuffelResponse<OrderCancellation>>;
    /**
     * Retrieves a page of order cancellations. The results may be returned in any order.
     * @param {Object.<ListOrderCancellationsParams>} params - Endpoint options (optional: limit, after, before, order_id)
     * @link https://duffel.com/docs/api/order-cancellations/get-order-cancellations
     */
    list: (params?: ListOrderCancellationsParams | undefined) => Promise<DuffelResponse<OrderCancellation[]>>;
    /**
     * Retrieves a generator of all order cancellations. The results may be returned in any order.
     * @param {Object.<ListOrderCancellationsParams>} params - Endpoint options (optional: limit, after, before, order_id)
     * @link https://duffel.com/docs/api/order-cancellations/get-order-cancellations
     */
    listWithGenerator: (params?: ListOrderCancellationsParams | undefined) => AsyncGenerator<DuffelResponse<OrderCancellation>, void, unknown>;
    /**
     * Create order cancellation
     * @description To begin the process of cancelling an order you need to create an order cancellation.
     * @param order_id - Duffel's unique identifier for the order
     * @link https://duffel.com/docs/api/order-cancellations/create-order-cancellation
     */
    create: (options: CreateOrderCancellation) => Promise<DuffelResponse<OrderCancellation>>;
    /**
     * Confirm order cancellation
     * @description Once you've created a pending order cancellation, you'll know the `refund_amount` you're due to get back.
     * @param {string} id - Duffel's unique identifier for the order to cancel
     * @link https://duffel.com/docs/api/order-cancellations/confirm-order-cancellation
     */
    confirm: (id: string) => Promise<DuffelResponse<OrderCancellation>>;
}

declare class Orders extends Resource {
    /**
     * Endpoint path
     */
    path: string;
    constructor(args: any);
    /**
     * Retrieves an order by its ID
     * @param {string} id - Duffel's unique identifier for the order
     */
    get: (id: string) => Promise<DuffelResponse<Order>>;
    /**
     * Retrieves a page of orders. The results may be returned in any order.
     * @param {Object} [options] - Pagination options (optional: limit, after, before)
     * @link https://duffel.com/docs/api/orders/get-orders
     */
    list: (options?: (PaginationMeta & ListParamsOrders) | undefined) => Promise<DuffelResponse<Order[]>>;
    /**
     * Retrieves a generator of all orders. The results may be returned in any order.
     * You can optionally filter the results by the `awaiting_payment` state and sort by the `payment_required_by` date.
     * @param {Object} [options] - Optional query parameters: awaiting_payment, sort
     * @link https://duffel.com/docs/api/orders/get-orders
     */
    listWithGenerator: (options?: ListParamsOrders | undefined) => AsyncGenerator<DuffelResponse<Order>, void, unknown>;
    /**
     * Creates a booking with an airline based on an offer.
     */
    create: (options: CreateOrder) => Promise<DuffelResponse<Order>>;
    /**
     * Updates a single order
     * @description Some order fields are updateable. Each field that can be updated is detailed in the request object.
     * @param {string} id - Duffel's unique identifier for the order
     * @param {Object.UpdateSingleOrder} options
     * @example (id: 'ord_00009hthhsUZ8W4LxQgkjo', { metadata: { 'payment_intent_id': 'pit_00009htYpSCXrwaB9DnUm2' } } )
     * @link https://duffel.com/docs/api/orders/update-order-by-id
     */
    update: (id: string, options: UpdateSingleOrder) => Promise<DuffelResponse<Order>>;
}

/**
 *
 * To change an order, you'll need to create an order change request.
 * This is still in PREVIEW mode
 * @export
 * @class OrderChangeRequests
 * @extends {Resource}
 */
declare class OrderChangeRequests extends Resource {
    /**
     * Endpoint path
     */
    path: string;
    constructor(args: any);
    /**
     * Retrieves an order change request by its ID
     * @param {string} id - The ID of your order change request
     */
    get: (id: string) => Promise<DuffelResponse<OrderChangeRequestResponse>>;
    /**
     *
     * To change flights on an existing paid order, you'll need to create an order change request.
     * @link https://duffel.com/docs/api/order-change-requests/create-order-change-request
     * @memberof OrderChangeRequests
     */
    create: (options: CreateOrderChangeRequest) => Promise<DuffelResponse<OrderChangeRequestResponse>>;
}

/**
 * After you've searched for flights to add to your order by creating an order change request, we'll send your search to a range of airlines, which may return order change offers.
 * This is still in PREVIEW mode
 * @export
 * @class OrderChangeOffers
 * @extends {Resource}
 */
declare class OrderChangeOffers extends Resource {
    /**
     * Endpoint path
     */
    path: string;
    constructor(args: any);
    /**
     * Retrieves an order change offer by its ID
     * @param {string} id - The ID of your order change offer
     * @link https://duffel.com/docs/api/order-change-offers/get-order-change-offer-by-id
     */
    get: (id: string) => Promise<DuffelResponse<OrderChangeOffer>>;
    /**
     * Retrieves a page of order change offers. The results may be returned in any order.
     * @param {Object} [options] - Pagination options (optional: limit, after, before)
     */
    list: (options?: PaginationMeta | undefined) => Promise<DuffelResponse<OrderChangeOffer[]>>;
    /**
     * Retrieves a generator of all order change offers. The results may be returned in any order.
     */
    listWithGenerator: () => AsyncGenerator<DuffelResponse<OrderChangeOffer>, void, unknown>;
}

/**
 * Once you've created an order change request, and you've chosen which slices to add and remove, you'll then want to create an order change.
 */
declare class OrderChanges extends Resource {
    /**
     * Endpoint path
     */
    path: string;
    constructor(args: any);
    /**
     * To begin the process of changing an order you need to create an order change.
     * The OrderChange will contain the `selected_order_change_offer` reference of the change you wish to make to your order.
     * @link https://duffel.com/docs/api/order-changes/create-order-change
     */
    create: (options: CreateOrderChangeParameters) => Promise<DuffelResponse<OrderChangeOfferSlice>>;
    /**
     * Retrieves an order change by its ID
     * @param {string} id - Duffel's unique identifier for the order change
     * @link https://duffel.com/docs/api/order-changes/get-order-change-by-id
     */
    get: (id: string) => Promise<DuffelResponse<OrderChangeOfferSlice>>;
    /**
     * Once you've created a pending order change, you'll know the change_total_amount due for the change.
     * @param {string} id - Duffel's unique identifier for the order change
     * @param {payment} Object - The payment details to use to pay for the order change, if there is an amount to be paid. Some order changes may not need this if they instead refund an amount. In those cases, you can pass any empty object.
     * @link https://duffel.com/docs/api/order-changes/confirm-order-change
     */
    confirm: (id: string, options: Partial<ConfirmOrderChangePayment>) => Promise<DuffelResponse<OrderChangeOfferSlice>>;
}

declare class Payments extends Resource {
    /**
     * Endpoint path
     */
    path: string;
    constructor(args: any);
    /**
     * Creates a payment for an existing pay later order.
     * An order can be paid for up to the time limit indicated in `payment_required_by`, after which the space held for the order will be released and you will have to create a new order.
     * @param {string} order_id
     * @param {string} payment
     */
    create: (options: CreatePayment) => Promise<DuffelResponse<Payment>>;
}

declare class SeatMaps extends Resource {
    /**
     * Endpoint path
     */
    path: string;
    constructor(args: any);
    /**
     * Gets seat maps by specific parameters. At the moment we only support querying by an offer ID.
     * @param {string} offer_id - Duffel's unique identifier for the offer
     * @link https://duffel.com/docs/api/seat-maps/get-seat-maps
     */
    get: (params: {
        offer_id: string;
    }) => Promise<DuffelResponse<SeatMap>>;
}

/** Aircraft are used to describe what passengers will fly in for a given trip
 * @class
 * @link https://duffel.com/docs/api/aircraft
 */
declare class Aircraft extends Resource {
    /**
     * Endpoint path
     */
    path: string;
    constructor(args: any);
    /**
     * Retrieves an aircraft by its ID
     * @param {string} id - Duffel's unique identifier for the aircraft
     * @link https://duffel.com/docs/api/aircraft/get-aircraft-by-id
     */
    get: (id: string) => Promise<DuffelResponse<Aircraft$1>>;
    /**
     * Retrieves a page of aircraft. The results may be returned in any order.
     * @param {Object} [options] - Pagination options (optional: limit, after, before)
     * @link https://duffel.com/docs/api/aircraft/get-aircraft
     */
    list: (options?: PaginationMeta | undefined) => Promise<DuffelResponse<Aircraft$1[]>>;
    /**
     * Retrieves a generator of all aircraft. The results may be returned in any order.
     * @link https://duffel.com/docs/api/aircraft/get-aircraft
     */
    listWithGenerator: () => AsyncGenerator<DuffelResponse<Aircraft$1>, void, unknown>;
}

/** Airlines are used to identify the air travel companies selling and operating flights
 * @class
 * @link https://duffel.com/docs/api/airlines */
declare class Airlines extends Resource {
    /**
     * Endpoint path
     */
    path: string;
    constructor(args: any);
    /**
     * Retrieves an airline by its ID
     * @param {string} id - Duffel's unique identifier for the airline
     * @link https://duffel.com/docs/api/airlines/get-airline-by-id
     */
    get: (id: string) => Promise<DuffelResponse<Airline>>;
    /**
     * Retrieves a page of airlines. The results may be returned in any order.
     * @param {Object} [options] - Pagination options (optional: limit, after, before)
     * @link https://duffel.com/docs/api/airlines/get-airlines
     */
    list: (options?: PaginationMeta | undefined) => Promise<DuffelResponse<Airline[]>>;
    /**
     * Retrieves a generator of all airlines. The results may be returned in any order.
     * @link https://duffel.com/docs/api/airlines/get-airlines
     */
    listWithGenerator: () => AsyncGenerator<DuffelResponse<Airline>, void, unknown>;
}

/** Airports are used to identify origins and destinations in journey slices
 * @class
 * @link https://duffel.com/docs/api/airports
 */
declare class Airports extends Resource {
    /**
     * Endpoint path
     */
    path: string;
    constructor(args: any);
    /**
     * Retrieves an airport by its ID
     * @param {string} id - Duffel's unique identifier for the airport
     * @link https://duffel.com/docs/api/airports/get-airport-by-id
     */
    get: (id: string) => Promise<DuffelResponse<Airport>>;
    /**
     * Retrieves a page of airports. The results may be returned in any order.
     * @param {Object} [options] - Pagination options (optional: limit, after, before)
     * @link https://duffel.com/docs/api/airports/get-airports
     */
    list: (options?: PaginationMeta | undefined) => Promise<DuffelResponse<Airport[]>>;
    /**
     * Retrieves a generator of all airports. The results may be returned in any order.
     * @link https://duffel.com/docs/api/airports/get-airports
     */
    listWithGenerator: () => AsyncGenerator<DuffelResponse<Airport>, void, unknown>;
}

interface DuffelAPIClient {
    aircraft: Aircraft;
    airlines: Airlines;
    airports: Airports;
    offers: Offers;
    offerRequests: OfferRequests;
    orders: Orders;
    orderChangeRequests: OrderChangeRequests;
    orderChangeOffers: OrderChangeOffers;
    orderChanges: OrderChanges;
    orderCancellations: OrderCancellations;
    payments: Payments;
    seatMaps: SeatMaps;
}
declare class Duffel {
    private client;
    aircraft: Aircraft;
    airlines: Airlines;
    airports: Airports;
    offerRequests: OfferRequests;
    offers: Offers;
    orders: Orders;
    orderChangeRequests: OrderChangeRequests;
    orderChangeOffers: OrderChangeOffers;
    orderChanges: OrderChanges;
    orderCancellations: OrderCancellations;
    payments: Payments;
    seatMaps: SeatMaps;
    paymentIntents: PaymentIntents;
    constructor(config: Config);
}

export { Aircraft$1 as Aircraft, Airline, Airport, ApiResponseError, ApiResponseMeta, BaggageType, CabinClass, City, ConfirmOrderChangePayment, CreateOfferRequest, CreateOfferRequestQueryParameters, CreateOrder, CreateOrderCancellation, CreateOrderChangeParameters, CreateOrderChangeRequest, CreateOrderPassenger, CreatePayment, CreatePaymentIntent, Duffel, DuffelAPIClient, DuffelError, DuffelPassengerGender, DuffelPassengerTitle, DuffelPassengerType, DuffelResponse, FlightsConditions, ListOffersParams, ListOrderCancellationsParams, ListParamsOrders, LoyaltyProgrammeAccount, LoyaltyProgrammeAccounts, Offer, OfferAvailableService, OfferAvailableServiceBaggageMetadata, OfferAvailableServiceMetadataMap, OfferAvailableServiceType, OfferPassenger, OfferRequest, OfferRequestPassenger, OfferRequestSlice, OfferSlice, OfferSliceSegment, OfferSliceSegmentPassenger, OfferSliceSegmentPassengerBaggage, Order, OrderCancellation, OrderChange, OrderChangeOffer, OrderChangeOfferSlice, OrderChangeOfferSlices, OrderChangeOffers$1 as OrderChangeOffers, OrderChangeRequestResponse, OrderChangeSliceResponse, OrderDocument, OrderDocumentsType, OrderPassenger, OrderPassengerIdentityDocument, OrderPayment, OrderPaymentStatus, OrderSegmentPassenger, OrderSegmentPassengerBaggage, OrderService, OrderServiceBaggageMetadata, OrderSlice, OrderSliceSegment, PaginationMeta, PassengerIdentityDocumentType, Payment, PaymentIntent, PaymentRequirements, PaymentType, Place, PlaceType, SDKOptions, Seat, SeatMap, SeatMapCabin, SeatMapCabinRow, SeatMapCabinRowSection, SeatMapCabinRowSectionAvailableService, SeatMapCabinRowSectionElement, SeatMapCabinRowSectionElementAmenity, SeatMapCabinRowSectionElementBassinet, SeatMapCabinRowSectionElementCloset, SeatMapCabinRowSectionElementEmpty, SeatMapCabinRowSectionElementExitRow, SeatMapCabinRowSectionElementGalley, SeatMapCabinRowSectionElementLavatory, SeatMapCabinRowSectionElementSeat, SeatMapCabinRowSectionElementStairs, SeatMapCabinRowSectionElementType, UpdateOffer, UpdateSingleOrder };
